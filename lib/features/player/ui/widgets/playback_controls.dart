import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart'; // Use ConsumerWidget
import 'package:just_audio/just_audio.dart'; // Required for PlayerState and ProcessingState

// Import the provider generated by @riverpod
import '../../providers/player_provider.dart';
// No longer need to import PlayerScreenState or PlayerNotifier directly here,
// as they are accessed via the provider.

/// PlaybackControls: A widget displaying the audio playback controls.
///
/// Includes a progress slider, time indicators, playback speed button,
/// skip buttons, and a central play/pause/replay button.
/// It directly watches/reads the `playerProvider` using Riverpod.
class PlaybackControls extends ConsumerWidget { // Changed to ConsumerWidget
  /// Constructor no longer needs state or notifier parameters.
  const PlaybackControls({ Key? key }) : super(key: key);

  /// Helper function to format Duration into MM:SS string format.
  String _formatDuration(Duration duration) {
    // Handle potential negative durations during initialization or edge cases
    if (duration.isNegative) return "00:00";

    // Pad minutes and seconds with leading zeros if needed
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    final String twoDigitMinutes = twoDigits(duration.inMinutes.remainder(60));
    final String twoDigitSeconds = twoDigits(duration.inSeconds.remainder(60));
    return "$twoDigitMinutes:$twoDigitSeconds";
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) { // Added WidgetRef ref
    // --- Access State and Notifier via Riverpod ---
    // Watch the provider's state. The widget will rebuild when the state changes.
    final state = ref.watch(playerProvider);
    // Read the notifier instance. Typically used in callbacks (onPressed, etc.).
    // Reading here is fine as the notifier instance itself rarely changes.
    final notifier = ref.read(playerProvider.notifier);

    // Extract playback state details for easier access
    final bool isPlaying = state.playerState.playing;
    final ProcessingState processingState = state.playerState.processingState;

    // --- Build Control Bar UI ---
    return Container(
      // Styling for the control bar container
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            spreadRadius: 0,
            blurRadius: 10,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // --- Progress Row (Slider + Time Texts) ---
          Row(
            children: [
              Padding(
                padding: const EdgeInsets.only(right: 8.0),
                child: Text(
                  _formatDuration(state.currentPosition), // Use state from ref.watch
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ),
              Expanded(
                child: (state.totalDuration > Duration.zero)
                    ? Slider(
                        value: state.currentPosition.inMilliseconds
                            .toDouble()
                            .clamp(
                              0.0,
                              state.totalDuration.inMilliseconds.toDouble(),
                            ),
                        min: 0.0,
                        max: state.totalDuration.inMilliseconds.toDouble(),
                        secondaryTrackValue: state.bufferedPosition.inMilliseconds
                            .toDouble()
                            .clamp(
                                0.0,
                                state.totalDuration.inMilliseconds.toDouble()),
                        onChanged: (value) {
                          // Use notifier from ref.read
                          notifier.seek(Duration(milliseconds: value.toInt()));
                        },
                        activeColor: Theme.of(context).colorScheme.primary,
                        inactiveColor: Theme.of(context).colorScheme.primary.withOpacity(0.3),
                      )
                    : const Slider(value: 0.0, min: 0.0, max: 1.0, onChanged: null),
              ),
              Padding(
                padding: const EdgeInsets.only(left: 8.0),
                child: Text(
                  _formatDuration(state.totalDuration), // Use state from ref.watch
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ),
            ],
          ),
          const SizedBox(height: 0),

          // --- Control Buttons Row ---
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // --- Speed Button ---
              InkWell(
                onTap: notifier.changeSpeed, // Use notifier from ref.read
                borderRadius: BorderRadius.circular(15),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: Colors.grey[200],
                    borderRadius: BorderRadius.circular(15),
                  ),
                  child: Text(
                    // Use state from ref.watch
                    '${state.playbackSpeed.toStringAsFixed(state.playbackSpeed == 1.0 || state.playbackSpeed == 2.0 ? 0 : 2)}x',
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 12,
                    ),
                  ),
                ),
              ),

              // --- Skip Backward Button ---
              IconButton(
                icon: const Icon(Icons.replay_10),
                iconSize: 30,
                tooltip: "Rewind 10 seconds",
                onPressed: notifier.skipBackward, // Use notifier from ref.read
              ),

              // --- Play/Pause/Replay/Loading Button ---
              SizedBox(
                width: 54, height: 54,
                // Pass context, state parts, and notifier to the helper method
                child: _buildPlayPauseButton(context, isPlaying, processingState, notifier),
              ),

              // --- Skip Forward Button ---
              IconButton(
                icon: const Icon(Icons.forward_10),
                iconSize: 30,
                tooltip: "Forward 10 seconds",
                onPressed: notifier.skipForward, // Use notifier from ref.read
              ),

              // --- Placeholder for alignment ---
              const SizedBox(width: 48),
            ],
          ),
          const SizedBox(height: 4),
        ],
      ),
    );
  }

  /// Builds the central Play/Pause/Replay/Loading button.
  /// Now takes notifier as a parameter since it's not directly accessible inside this static-like method.
  Widget _buildPlayPauseButton(
    BuildContext context,
    bool isPlaying,
    ProcessingState processingState,
    Player notifier, // Pass the notifier instance
  ) {
     if (processingState == ProcessingState.loading || processingState == ProcessingState.buffering) {
       return Center(
         child: SizedBox(
           width: 30.0,
           height: 30.0,
           child: CircularProgressIndicator(
             strokeWidth: 2.5,
             valueColor: AlwaysStoppedAnimation<Color>(Theme.of(context).colorScheme.primary),
           ),
         ),
       );
     } else {
       return IconButton(
         iconSize: 50,
         tooltip: isPlaying ? "Pause" : "Play",
         icon: Icon(
           (isPlaying)
               ? Icons.pause_circle_filled
               : (processingState == ProcessingState.completed
                   ? Icons.replay_circle_filled
                   : Icons.play_circle_filled),
           color: Theme.of(context).colorScheme.primary,
         ),
         onPressed: () {
           if (isPlaying) {
             notifier.pause(); // Use the passed notifier
           } else if (processingState == ProcessingState.completed) {
             notifier.seek(Duration.zero); // Use the passed notifier
             notifier.play(); // Use the passed notifier
           } else {
             notifier.play(); // Use the passed notifier
           }
         },
       );
     }
   }
}